module RIAPP {
    export module MOD {
        export module collection {
            //local variables for optimization
            var utils = global.utils, ValidationError = binding.ValidationError;

            export var consts = {
                DATA_TYPE: MOD.consts.DATA_TYPE,
                DATE_CONVERSION: MOD.consts.DATE_CONVERSION,
                SORT_ORDER: { ASC: 0, DESC: 1 },
                COLL_CHANGE_TYPE: { REMOVE: '0', ADDED: '1', RESET: '2', REMAP_KEY: '3' },
            };
            var DATA_TYPE = consts.DATA_TYPE, COLL_CHANGE_TYPE = consts.COLL_CHANGE_TYPE, valueUtils = MOD.utils.valueUtils;

            export interface IPermissions { canAddRow: boolean; canEditRow: boolean; canDeleteRow: boolean; canRefreshRow: boolean; }

            export interface IFieldInfo {
                isPrimaryKey: number;
                isRowTimeStamp: boolean;
                dataType: number;
                isNullable: boolean;
                maxLength: number;
                isReadOnly: boolean;
                isAutoGenerated: boolean;
                allowClientDefault: boolean;
                dateConversion: number;
                isClientOnly: boolean;
                isCalculated: boolean;
                isNeedOriginal: boolean;
                dependentOn: string;
                range: string;
                regex: string;
                isNavigation: boolean;
                fieldName: string;
                dependents?: string[];
            }

            export class CollectionItem extends RIAPP.BaseObject implements binding.IErrorNotification, MOD.utils.IEditable, MOD.utils.ISubmittable {
                _fkey: string;
                _isEditing: boolean;
                _saveVals: { [fieldName: string]: any; };
                _vals: { [fieldName: string]: any; };
                _notEdited: boolean;

                constructor() {
                    super();
                    this._fkey = null;
                    this._isEditing = false;
                    this._saveVals = null;
                    this._vals = {};
                    this._notEdited = true;
                }
                _getEventNames() {
                    var base_events = super._getEventNames();
                    return ['errors_changed'].concat(base_events);
                }
                addOnErrorsChanged(fn: (sender: any, args: {}) => void, namespace?: string) {
                    this.addHandler('errors_changed', fn, namespace);
                }
                removeOnErrorsChanged(namespace?: string) {
                    this.removeHandler('errors_changed', namespace);
                }
                _onErrorsChanged(args: any) {
                    this.raiseEvent('errors_changed', args);
                }
                _onError(error, source): boolean {
                    var isHandled = super._onError(error, source);
                    if (!isHandled) {
                        return this._collection._onError(error, source);
                    }
                    return isHandled;
                }
                _beginEdit(): boolean {
                    var coll = this._collection, isHandled: boolean;
                    if (coll.isEditing) {
                        var eitem = coll._EditingItem;
                        if (eitem === this)
                            return false;
                        try {
                            eitem.endEdit();
                            if (eitem.getIsHasErrors()) {
                                this._onError(new ValidationError(eitem.getAllErrors(), eitem), eitem);
                                eitem.cancelEdit();
                            }
                        } catch (ex) {
                            isHandled = this._onError(ex, eitem);
                            eitem.cancelEdit();
                            global.reThrow(ex, isHandled);
                        }
                    }
                    this._isEditing = true;
                    this._saveVals = utils.shallowCopy(this._vals);
                    this._collection.currentItem = this;
                    return true;
                }
                _endEdit(): boolean {
                    if (!this._isEditing)
                        return false;
                    var validation_errors, coll = this._collection, self = this;
                    if (this.getIsHasErrors()) {
                        return false;
                    }
                    coll._removeAllErrors(this); //revalidate all
                    validation_errors = this._validateAll();
                    if (validation_errors.length > 0) {
                        coll._addErrors(self, validation_errors);
                    }
                    if (this.getIsHasErrors()) {
                        return false;
                    }
                    this._isEditing = false;
                    this._saveVals = null;
                    return true;
                }
                _validate() {
                    return this._collection._validateItem(this);
                }
                _skipValidate(fieldInfo, val) {
                    return false;
                }
                _validateField(fieldName): binding.IValidationInfo {
                    var val, fieldInfo = this.getFieldInfo(fieldName), res: binding.IValidationInfo = null;
                    try {
                        val = this._vals[fieldName];
                        if (this._skipValidate(fieldInfo, val))
                            return res;
                        if (this._isNew) {
                            if (val === null && !fieldInfo.isNullable && !fieldInfo.isReadOnly && !fieldInfo.isAutoGenerated)
                                throw new Error(RIAPP.ERRS.ERR_FIELD_ISNOT_NULLABLE);
                        }
                        else {
                            if (val === null && !fieldInfo.isNullable && !fieldInfo.isReadOnly)
                                throw new Error(RIAPP.ERRS.ERR_FIELD_ISNOT_NULLABLE);
                        }
                    } catch (ex) {
                        res = { fieldName: fieldName, errors: [ex.message] };
                    }
                    var tmp = this._collection._validateItemField(this, fieldName);
                    if (!!res && !!tmp) {
                        res.errors = res.errors.concat(tmp.errors);
                    }
                    else if (!!tmp)
                        res = tmp;
                    return res;
                }
                _validateAll(): binding.IValidationInfo[] {
                    var self = this, fields = this.getFieldNames(), errs: binding.IValidationInfo[] = [];
                    fields.forEach(function (fieldName) {
                        var res = self._validateField(fieldName);
                        if (!!res) {
                            errs.push(res);
                        }
                    });
                    var res = self._validate();
                    if (!!res) {
                        errs.push(res);
                    }
                    return errs;
                }
                _checkVal(fieldInfo, val) {
                    var res = val, ERRS = RIAPP.ERRS;
                    if (this._skipValidate(fieldInfo, val))
                        return res;
                    if (fieldInfo.isReadOnly && !(fieldInfo.allowClientDefault && this._isNew))
                        throw new Error(ERRS.ERR_FIELD_READONLY);
                    if ((val === null || (utils.check.isString(val) && !val)) && !fieldInfo.isNullable)
                        throw new Error(ERRS.ERR_FIELD_ISNOT_NULLABLE);

                    if (val === null)
                        return val;

                    switch (fieldInfo.dataType) {
                        case DATA_TYPE.None:
                            break;
                        case DATA_TYPE.Guid:
                        case DATA_TYPE.String:
                            if (!utils.check.isString(val)) {
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'String'));
                            }
                            if (fieldInfo.maxLength > 0 && val.length > fieldInfo.maxLength)
                                throw new Error(utils.format(ERRS.ERR_FIELD_MAXLEN, fieldInfo.maxLength));
                            if (fieldInfo.isNullable && val === '')
                                res = null;
                            if (!!fieldInfo.regex) {
                                var reg = new RegExp(fieldInfo.regex, "i");
                                if (!reg.test(val)) {
                                    throw new Error(utils.format(ERRS.ERR_FIELD_REGEX, val));
                                }
                            }
                            break;
                        case DATA_TYPE.Binary:
                            if (!utils.check.isArray(val)) {
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Array'));
                            }
                            if (fieldInfo.maxLength > 0 && val.length > fieldInfo.maxLength)
                                throw new Error(utils.format(ERRS.ERR_FIELD_MAXLEN, fieldInfo.maxLength));
                            break;
                        case DATA_TYPE.Bool:
                            if (!utils.check.isBoolean(val))
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Boolean'));
                            break;
                        case DATA_TYPE.Integer:
                        case DATA_TYPE.Decimal:
                        case DATA_TYPE.Float:
                            if (!utils.check.isNumber(val))
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Number'));
                            if (!!fieldInfo.range) {
                                utils.validation.checkNumRange(Number(val), fieldInfo.range);
                            }
                            break;
                        case DATA_TYPE.DateTime:
                        case DATA_TYPE.Date:
                            if (!utils.check.isDate(val))
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Date'));
                            if (!!fieldInfo.range) {
                                utils.validation.checkDateRange(val, fieldInfo.range);
                            }
                            break;
                        case DATA_TYPE.Time:
                            if (!utils.check.isDate(val))
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Time'));
                            break;
                        default:
                            throw new Error(utils.format(ERRS.ERR_PARAM_INVALID, 'dataType', fieldInfo.dataType));
                    }
                    return res;
                }
                _resetIsNew() {
                }
                _onAttaching() {
                }
                _onAttach() {
                }
                getFieldInfo(fieldName: string) {
                    return this._collection.getFieldInfo(fieldName);
                }
                getFieldNames() {
                    return this._collection.getFieldNames();
                }
                getFieldErrors(fieldName): MOD.binding.IValidationInfo[] {
                    var itemErrors = this._collection._getErrors(this);
                    if (!itemErrors)
                        return [];
                    var name = fieldName;
                    if (!fieldName)
                        fieldName = '*';
                    if (!itemErrors[fieldName])
                        return [];
                    if (fieldName == '*')
                        name = null;
                    return [
                        { fieldName: name, errors: itemErrors[fieldName] }
                    ];
                }
                getAllErrors(): MOD.binding.IValidationInfo[] {
                    var itemErrors = this._collection._getErrors(this);
                    if (!itemErrors)
                        return [];
                    var res: MOD.binding.IValidationInfo[] = [];
                    utils.forEachProp(itemErrors, function (name) {
                        var fieldName = null;
                        if (name !== '*') {
                            fieldName = name;
                        }
                        res.push({ fieldName: fieldName, errors: itemErrors[name] });
                    });
                    return res;
                }
                getErrorString() {
                    var itemErrors = this._collection._getErrors(this);
                    if (!itemErrors)
                        return '';
                    var res = [];
                    utils.forEachProp(itemErrors, function (name) {
                        res.push(utils.format('{0}: {1}', name, itemErrors[name]));
                    });
                    return res.join('|');
                }
                submitChanges(): IPromise<any> {
                    var deffered = utils.createDeferred();
                    deffered.reject();
                    return deffered.promise();
                }
                beginEdit() {
                    var coll = this._collection;
                    if (!this._beginEdit())
                        return false;
                    coll._onEditing(this, true, false);
                    this.raisePropertyChanged('isEditing');
                    return true;
                }
                endEdit() {
                    var coll = this._collection;
                    if (!this._endEdit())
                        return false;
                    coll._onEditing(this, false, false);
                    this._notEdited = false;
                    this.raisePropertyChanged('isEditing');
                    return true;
                }
                cancelEdit() {
                    if (!this._isEditing)
                        return false;
                    var coll = this._collection, isNew = this._isNew;
                    var changes = this._saveVals;
                    this._vals = this._saveVals;
                    this._saveVals = null;
                    coll._removeAllErrors(this);
                    //refresh User interface when values restored
                    coll.getFieldNames().forEach(function (name) {
                        if (changes[name] !== this._vals[name])
                            this.raisePropertyChanged(name);
                    }, this);

                    if (isNew && this._notEdited)
                        coll.removeItem(this);

                    this._isEditing = false;
                    coll._onEditing(this, false, true);
                    this.raisePropertyChanged('isEditing');
                    return true;
                }
                deleteItem() {
                    var coll = this._collection;
                    if (this._key === null)
                        return false;
                    if (!coll._onItemDeleting(this)) {
                        return false;
                    }
                    coll.removeItem(this);
                    return true;
                }
                getIsNew() {
                    return this._isNew;
                }
                getIsDeleted() {
                    return this._isDeleted;
                }
                getKey() {
                    return this._key;
                }
                getCollection() {
                    return this._collection;
                }
                getIsEditing() {
                    return this._isEditing;
                }
                getIsHasErrors() {
                    var itemErrors = this._collection._getErrors(this);
                    return !!itemErrors;
                }
                getIErrorNotification(): binding.IErrorNotification {
                    return this;
                }
                destroy() {
                    if (this._isDestroyed)
                        return;
                    this._isDestroyCalled = true;
                    this._fkey = null;
                    this._saveVals = null;
                    this._vals = {};
                    this._isEditing = false;
                    super.destroy();
                }
                toString() {
                    return 'CollectionItem';
                }
                get _isCanSubmit() { return false; }
                get _changeType() { return 0; }
                get _isNew() {
                    return false;
                }
                get _isDeleted() { return false; }
                get _key() { return this._fkey; }
                set _key(v) {
                    if (v !== null)
                        v = '' + v;
                    this._fkey = v;
                }
                get _collection(): Collection { return null; }
                get _isUpdating() {
                    var coll = this._collection;
                    if (!coll)
                        return false;
                    return coll.isUpdating;
                }
                get isEditing() { return this._isEditing; }
            }

            export interface ICollectionOptions {
                enablePaging: boolean; pageSize: number;
            }

            export interface ICollChangedArgs<TItem extends CollectionItem> { change_type: string; items: TItem[]; pos?: number[]; old_key?: string; new_key?: string; }
            export interface ICollFillArgs<TItem extends CollectionItem> { isBegin: boolean; rowCount: number; time: Date; isPageChanged: boolean; resetUI?: boolean; fetchedItems?: TItem[]; newItems?: TItem[]; }
            export interface ICollValidateArgs<TItem extends CollectionItem> { item: TItem; fieldName: string; errors: string[]; }
            export interface ICollItemStatusArgs<TItem extends CollectionItem> { item: TItem; oldChangeType: number; key: string; }
            export interface ICollItemAddedArgs<TItem extends CollectionItem> { item: TItem; isAddNewHandled: boolean; }

            export class BaseCollection<TItem extends CollectionItem> extends RIAPP.BaseObject {
                _options: ICollectionOptions;
                _isLoading: boolean;
                _EditingItem: TItem;
                _perms: IPermissions;
                _totalCount: number;
                _pageIndex: number;
                _items: TItem[];
                _itemsByKey: { [key: string]: TItem; };
                _currentPos: number;
                _newKey: number;
                _fieldMap: { [fieldName: string]: IFieldInfo; };
                _errors: { [item_key: string]: { [fieldName: string]: string[]; }; };
                _ignoreChangeErrors: boolean;
                _pkInfo: IFieldInfo[];
                _isUpdating: boolean;
                _waitQueue: MOD.utils.WaitQueue;

                constructor() {
                    super();
                    this._options = { enablePaging: false, pageSize: 50 };
                    this._isLoading = false;
                    this._EditingItem = null;
                    this._perms = { canAddRow: true, canEditRow: true, canDeleteRow: true, canRefreshRow: false };
                    //includes stored on server
                    this._totalCount = 0;
                    this._pageIndex = 0;
                    this._items = [];
                    this._itemsByKey = {};
                    this._currentPos = -1;
                    this._newKey = 0;
                    this._fieldMap = {};
                    this._errors = {};
                    this._ignoreChangeErrors = false;
                    this._pkInfo = null;
                    this._isUpdating = false;
                    this._waitQueue = new MOD.utils.WaitQueue(this);
                }

                static getEmptyFieldInfo(fieldName: string) {
                    var fieldInfo: IFieldInfo = {
                        isPrimaryKey: 0,
                        isRowTimeStamp: false,
                        dataType: DATA_TYPE.None,
                        isNullable: true,
                        maxLength: -1,
                        isReadOnly: false,
                        isAutoGenerated: false,
                        allowClientDefault: false,
                        dateConversion: collection.consts.DATE_CONVERSION.None,
                        isClientOnly: true,
                        isCalculated: false,
                        isNeedOriginal: false,
                        dependentOn: null,
                        range: null,
                        regex: null,
                        isNavigation: false,
                        fieldName: fieldName
                    };
                    return fieldInfo;
                }
                _getEventNames() {
                    var base_events = super._getEventNames();
                    return ['begin_edit', 'end_edit', 'fill', 'coll_changed', 'item_deleting', 'item_adding', 'item_added',
                        'validate', 'current_changing', 'page_changing', 'errors_changed', 'status_changed', 'clearing',
                        'cleared', 'commit_changes'].concat(base_events);
                }
                addOnClearing(fn: (sender: BaseCollection<TItem>, args: {}) => void, namespace?: string) {
                    this.addHandler('clearing', fn, namespace);
                }
                removeOnClearing(namespace?: string) {
                    this.removeHandler('clearing', namespace);
                }
                addOnCleared(fn: (sender: BaseCollection<TItem>, args: {}) => void, namespace?: string) {
                    this.addHandler('cleared', fn, namespace);
                }
                removeOnCleared(namespace?: string) {
                    this.removeHandler('cleared', namespace);
                }
                addOnFill(fn: (sender: BaseCollection<TItem>, args: ICollFillArgs<TItem>) => void, namespace?: string) {
                    this.addHandler('fill', fn, namespace);
                }
                removeOnFill(namespace?: string) {
                    this.removeHandler('fill', namespace);
                }
                addOnCollChanged(fn: (sender: BaseCollection<TItem>, args: ICollChangedArgs<TItem>) => void, namespace?: string) {
                    this.addHandler('coll_changed', fn, namespace);
                }
                removeOnCollChanged(namespace?: string) {
                    this.removeHandler('coll_changed', namespace);
                }
                addOnValidate(fn: (sender: BaseCollection<TItem>, args: ICollValidateArgs<TItem>) => void, namespace?: string) {
                    this.addHandler('validate', fn, namespace);
                }
                removeOnValidate(namespace?: string) {
                    this.removeHandler('validate', namespace);
                }
                addOnItemDeleting(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isCancel: boolean; }) => void, namespace?: string) {
                    this.addHandler('item_deleting', fn, namespace);
                }
                removeOnItemDeleting(namespace?: string) {
                    this.removeHandler('item_deleting', namespace);
                }
                addOnItemAdding(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isCancel: boolean; }) => void, namespace?: string) {
                    this.addHandler('item_adding', fn, namespace);
                }
                removeOnItemAdding(namespace?: string) {
                    this.removeHandler('item_adding', namespace);
                }
                addOnItemAdded(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isAddNewHandled: boolean; }) => void, namespace?: string) {
                    this.addHandler('item_added', fn, namespace);
                }
                removeOnItemAdded(namespace?: string) {
                    this.removeHandler('item_added', namespace);
                }
                addOnCurrentChanging(fn: (sender: BaseCollection<TItem>, args: { newCurrent: TItem; }) => void, namespace?: string) {
                    this.addHandler('current_changing', fn, namespace);
                }
                removeOnCurrentChanging(namespace?: string) {
                    this.removeHandler('current_changing', namespace);
                }
                addOnPageChanging(fn: (sender: BaseCollection<TItem>, args: { page: number; isCancel: boolean; }) => void, namespace?: string) {
                    this.addHandler('page_changing', fn, namespace);
                }
                removeOnPageChanging(namespace?: string) {
                    this.removeHandler('page_changing', namespace);
                }
                addOnErrorsChanged(fn: (sender: BaseCollection<TItem>, args: { item: TItem; }) => void, namespace?: string) {
                    this.addHandler('errors_changed', fn, namespace);
                }
                removeOnErrorsChanged(namespace?: string) {
                    this.removeHandler('errors_changed', namespace);
                }
                addOnBeginEdit(fn: (sender: BaseCollection<TItem>, args: { item: TItem; }) => void, namespace?: string) {
                    this.addHandler('begin_edit', fn, namespace);
                }
                removeOnBeginEdit(namespace?: string) {
                    this.removeHandler('begin_edit', namespace);
                }
                addOnEndEdit(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isCanceled: boolean; }) => void, namespace?: string) {
                    this.addHandler('end_edit', fn, namespace);
                }
                removeOnEndEdit(namespace?: string) {
                    this.removeHandler('end_edit', namespace);
                }
                addOnCommitChanges(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isBegin: boolean; isRejected: boolean; changeType: number; }) => void, namespace?: string) {
                    this.addHandler('commit_changes', fn, namespace);
                }
                removeOnCommitChanges(namespace?: string) {
                    this.removeHandler('commit_changes', namespace);
                }
                addOnStatusChanged(fn: (sender: BaseCollection<TItem>, args: ICollItemStatusArgs<TItem>) => void, namespace?: string) {
                    this.addHandler('status_changed', fn, namespace);
                }
                removeOnStatusChanged(namespace?: string) {
                    this.removeHandler('status_changed', namespace);
                }
                _getStrValue(val, fieldInfo: IFieldInfo) {
                    var dcnv = fieldInfo.dateConversion, stz = utils.get_timeZoneOffset();
                    return valueUtils.stringifyValue(val, dcnv, stz);
                }
                _getPKFieldInfos(): IFieldInfo[] {
                    if (!!this._pkInfo)
                        return this._pkInfo;
                    var fldMap = this._fieldMap, pk = [];
                    utils.forEachProp(fldMap, function (fldName) {
                        if (fldMap[fldName].isPrimaryKey > 0) {
                            pk.push(fldMap[fldName]);
                        }
                    });
                    pk.sort(function (a, b) {
                        return a.isPrimaryKey - b.isPrimaryKey;
                    });
                    this._pkInfo = pk;
                    return this._pkInfo;
                }
                _onError(error, source): boolean {
                    var isHandled = super._onError(error, source);
                    if (!isHandled) {
                        return global._onError(error, source);
                    }
                    return isHandled;
                }
                _onCurrentChanging(newCurrent: TItem) {
                    try {
                        this.endEdit();
                    } catch (ex) {
                        global.reThrow(ex, this._onError(ex, this));
                    }
                    this.raiseEvent('current_changing', { newCurrent: newCurrent });
                }
                _onCurrentChanged() {
                    this.raisePropertyChanged('currentItem');
                }
                _onEditing(item: TItem, isBegin: boolean, isCanceled: boolean) {
                    if (this._isUpdating)
                        return;
                    if (isBegin) {
                        this._EditingItem = item;
                        this.raiseEvent('begin_edit', { item: item });
                    }
                    else {
                        this._EditingItem = null;
                        this.raiseEvent('end_edit', { item: item, isCanceled: isCanceled });
                    }
                }
                //used by descendants when commiting submits for items
                _onCommitChanges(item: TItem, isBegin: boolean, isRejected: boolean, changeType: number) {
                    this.raiseEvent('commit_changes', { item: item, isBegin: isBegin, isRejected: isRejected, changeType: changeType });
                }
                //occurs when item changeType Changed (not used in simple collections)
                _onItemStatusChanged(item: TItem, oldChangeType: number) {
                    this.raiseEvent('status_changed', { item: item, oldChangeType: oldChangeType, key: item._key });
                }
                _validateItem(item: TItem): MOD.binding.IValidationInfo {
                    var args = { item: item, fieldName: null, errors: [] };
                    this.raiseEvent('validate', args);
                    if (!!args.errors && args.errors.length > 0)
                        return { fieldName: null, errors: args.errors };
                    else
                        return null;
                }
                _validateItemField(item: TItem, fieldName: string): MOD.binding.IValidationInfo {
                    var args = { item: item, fieldName: fieldName, errors: [] };
                    this.raiseEvent('validate', args);
                    if (!!args.errors && args.errors.length > 0)
                        return { fieldName: fieldName, errors: args.errors };
                    else
                        return null;
                }
                _addErrors(item: TItem, errors: MOD.binding.IValidationInfo[]) {
                    var self = this;
                    this._ignoreChangeErrors = true;
                    try {
                        errors.forEach(function (err) {
                            self._addError(item, err.fieldName, err.errors);
                        });
                    } finally {
                        this._ignoreChangeErrors = false;
                    }
                    this._onErrorsChanged(item);
                }
                _addError(item: TItem, fieldName: string, errors: string[]) {
                    if (!fieldName)
                        fieldName = '*';
                    if (!(utils.check.isArray(errors) && errors.length > 0)) {
                        this._removeError(item, fieldName);
                        return;
                    }
                    if (!this._errors[item._key])
                        this._errors[item._key] = {};
                    var itemErrors = this._errors[item._key];
                    itemErrors[fieldName] = errors;
                    if (!this._ignoreChangeErrors)
                        this._onErrorsChanged(item);
                }
                _removeError(item: TItem, fieldName: string) {
                    var itemErrors = this._errors[item._key];
                    if (!itemErrors)
                        return;
                    if (!fieldName)
                        fieldName = '*';
                    if (!itemErrors[fieldName])
                        return;
                    delete itemErrors[fieldName];
                    if (utils.getProps(itemErrors).length === 0) {
                        delete this._errors[item._key];
                    }
                    this._onErrorsChanged(item);
                }
                _removeAllErrors(item: TItem) {
                    var self = this, itemErrors = this._errors[item._key];
                    if (!itemErrors)
                        return;
                    delete this._errors[item._key];
                    self._onErrorsChanged(item);
                }
                _getErrors(item: TItem): { [fieldName: string]: string[]; } {
                    return this._errors[item._key];
                }
                _onErrorsChanged(item: TItem) {
                    var args = { item: item };
                    this.raiseEvent('errors_changed', args);
                    item._onErrorsChanged(args);
                }
                _onItemDeleting(item: TItem) {
                    var args = { item: item, isCancel: false };
                    this.raiseEvent('item_deleting', args);
                    return !args.isCancel;
                }
                _onFillStart(args: { isBegin: boolean; rowCount: number; time: Date; isPageChanged: boolean; }) {
                    this.raiseEvent('fill', args);
                }
                _onFillEnd(args: { isBegin: boolean; rowCount: number; time: Date; isPageChanged: boolean; resetUI: boolean; fetchedItems: TItem[]; newItems: TItem[]; }) {
                    this.raiseEvent('fill', args);
                }
                _onItemsChanged(args: { change_type: string; items: TItem[]; pos?: number[]; old_key?: string; new_key?: string; }) {
                    this.raiseEvent('coll_changed', args);
                }
                //new item is being added, but is not in the collection now
                _onItemAdding(item: TItem) {
                    var args = { item: item, isCancel: false };
                    this.raiseEvent('item_adding', args);
                    if (args.isCancel)
                        global._throwDummy(new Error('operation canceled'));
                }
                //new item has been added and now is in editing state and is currentItem
                _onItemAdded(item: TItem) {
                    var args = { item: item, isAddNewHandled: false };
                    this.raiseEvent('item_added', args);
                }
                _createNew(): TItem {
                    throw new Error('_createNew Not implemented');
                }
                _attach(item: TItem, itemPos?: number) {
                    if (!!this._itemsByKey[item._key]) {
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_ATTACHED);
                    }
                    try {
                        this.endEdit();
                    } catch (ex) {
                        global.reThrow(ex, this._onError(ex, this));
                    }
                    var pos;
                    item._onAttaching();
                    if (utils.check.isNt(itemPos)) {
                        pos = this._items.length;
                        this._items.push(item);
                    }
                    else {
                        pos = itemPos;
                        utils.insertIntoArray(this._items, item, pos);
                    }
                    this._itemsByKey[item._key] = item;
                    this._onItemsChanged({ change_type: COLL_CHANGE_TYPE.ADDED, items: [item], pos: [pos] });
                    item._onAttach();
                    this.raisePropertyChanged('count');
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return pos;
                }
                _onRemoved(item: TItem, pos: number) {
                    try {
                        this._onItemsChanged({ change_type: COLL_CHANGE_TYPE.REMOVE, items: [item], pos: [pos] });
                    }
                    finally {
                        this.raisePropertyChanged('count');
                    }
                }
                _onPageSizeChanged() {
                }
                _onPageChanging() {
                    var args = { page: this.pageIndex, isCancel: false };
                    this._raiseEvent('page_changing', args);
                    if (!args.isCancel) {
                        try {
                            this.endEdit();
                        } catch (ex) {
                            global.reThrow(ex, this._onError(ex, this));
                        }
                    }
                    return !args.isCancel;
                }
                _onPageChanged() {
                }
                _setCurrentItem(v: TItem) {
                    var self = this, oldPos = self._currentPos;
                    if (!v) {
                        if (oldPos !== -1) {
                            self._onCurrentChanging(null);
                            self._currentPos = -1;
                            self._onCurrentChanged();
                        }
                        return;
                    }
                    if (v._key === null)
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_DETACHED);
                    var oldItem, pos, item = self.getItemByKey(v._key);
                    if (!item) {
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_NOTFOUND);
                    }
                    oldItem = self.getItemByPos(oldPos);
                    pos = self._items.indexOf(v);
                    if (pos < 0)
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_NOTFOUND);
                    if (oldPos !== pos || oldItem !== v) {
                        self._onCurrentChanging(v);
                        self._currentPos = pos;
                        self._onCurrentChanged();
                    }
                }
                _destroyItems() {
                    this._items.forEach(function (item) {
                        item.destroy();
                    });
                }
                getFieldInfo(fieldName: string): IFieldInfo {
                    return this._fieldMap[fieldName];
                }
                getFieldNames(): string[] {
                    var fldMap = this._fieldMap;
                    return utils.getProps(fldMap);
                }
                cancelEdit() {
                    if (this.isEditing)
                        this._EditingItem.cancelEdit();
                }
                endEdit() {
                    var EditingItem;
                    if (this.isEditing) {
                        EditingItem = this._EditingItem;
                        if (!EditingItem.endEdit() && EditingItem.getIsHasErrors()) {
                            this._onError(new ValidationError(EditingItem.getAllErrors(), EditingItem), EditingItem);
                            this.cancelEdit();
                        }
                    }
                }
                getItemsWithErrors(): TItem[] {
                    var self = this, res: TItem[] = [];
                    utils.forEachProp(this._errors, function (key) {
                        var item = self.getItemByKey(key);
                        res.push(item);
                    });
                    return res;
                }
                addNew() {
                    var item: TItem, isHandled: boolean;
                    item = this._createNew();
                    this._onItemAdding(item);
                    this._attach(item, null);
                    try {
                        this.currentItem = item;
                        item.beginEdit();
                        this._onItemAdded(item);
                    }
                    catch (ex) {
                        isHandled = this._onError(ex, this);
                        item.cancelEdit();
                        global.reThrow(ex, isHandled);
                    }
                    return item;
                }
                getItemByPos(pos: number): TItem {
                    if (pos < 0 || pos >= this._items.length)
                        return null;
                    return this._items[pos];
                }
                getItemByKey(key: string): TItem {
                    if (!key)
                        throw new Error(RIAPP.ERRS.ERR_KEY_IS_EMPTY);
                    var map = this._itemsByKey;
                    return map['' + key];
                }
                findByPK(...vals: any[]): TItem {
                    if (arguments.length === 0)
                        return null;
                    var self = this, pkInfo = self._getPKFieldInfos(), arr = [], key, values = [];
                    if (vals.length === 1 && utils.check.isArray(vals[0])) {
                        values = vals[0];
                    }
                    else
                        values = vals;
                    if (values.length !== pkInfo.length) {
                        return null;
                    }
                    for (var i = 0, len = pkInfo.length; i < len; i += 1) {
                        arr.push(self._getStrValue(values[i], pkInfo[i]));
                    }

                    key = arr.join(';');
                    return self.getItemByKey(key);
                }
                moveFirst(skipDeleted?: boolean): boolean {
                    var pos = 0, old = this._currentPos;
                    if (old === pos)
                        return false;
                    var item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    if (!!skipDeleted) {
                        if (item._isDeleted) {
                            return this.moveNext(true);
                        }
                    }
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                movePrev(skipDeleted?: boolean): boolean {
                    var pos = -1, old = this._currentPos;
                    var item = this.getItemByPos(old);
                    if (!!item) {
                        pos = old;
                        pos -= 1;
                    }
                    item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    if (!!skipDeleted) {
                        if (item._isDeleted) {
                            this._currentPos = pos;
                            return this.movePrev(true);
                        }
                    }
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                moveNext(skipDeleted?: boolean): boolean {
                    var pos = -1, old = this._currentPos;
                    var item = this.getItemByPos(old);
                    if (!!item) {
                        pos = old;
                        pos += 1;
                    }
                    item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    if (!!skipDeleted) {
                        if (item._isDeleted) {
                            this._currentPos = pos;
                            return this.moveNext(true);
                        }
                    }
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                moveLast(skipDeleted?: boolean): boolean {
                    var pos = this._items.length - 1, old = this._currentPos;
                    if (old === pos)
                        return false;
                    var item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    if (!!skipDeleted) {
                        if (item._isDeleted) {
                            return this.movePrev(true);
                        }
                    }
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                goTo(pos: number): boolean {
                    var old = this._currentPos;
                    if (old === pos)
                        return false;
                    var item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                forEach(callback: (item: TItem) => void, thisObj?: any) {
                    this._items.forEach(callback, thisObj);
                }
                removeItem(item: TItem) {
                    if (item._key === null) {
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_DETACHED);
                    }
                    if (!this._itemsByKey[item._key])
                        return;
                    var oldPos = utils.removeFromArray(this._items, item);
                    if (oldPos < 0) {
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_NOTFOUND);
                    }
                    delete this._itemsByKey[item._key];
                    delete this._errors[item._key];
                    this._onRemoved(item, oldPos);
                    item._key = null;
                    item.removeHandler(null, null);
                    var test = this.getItemByPos(oldPos), curPos = this._currentPos;

                    //if detached item was current item
                    if (curPos === oldPos) {
                        if (!test) { //it was the last item
                            this._currentPos = curPos - 1;
                        }
                        this._onCurrentChanged();
                    }

                    if (curPos > oldPos) {
                        this._currentPos = curPos - 1;
                        this._onCurrentChanged();
                    }
                }
                getIsHasErrors(): boolean {
                    if (!this._errors)
                        return false;
                    return (utils.getProps(this._errors).length > 0);
                }
                sort(fieldNames: string[], sortOrder: string): IPromise<any> {
                    var self = this, deffered = utils.createDeferred();
                    setTimeout(function () {
                        try {
                            self.sortLocal(fieldNames, sortOrder);
                        }
                        finally {
                            deffered.resolve();
                        }
                    }, 0);
                    return deffered.promise();
                }
                sortLocal(fieldNames: string[], sortOrder: string) {
                    var mult = 1;
                    if (!!sortOrder && sortOrder.toUpperCase() === 'DESC')
                        mult = -1;
                    var fn_sort = function (a, b) {
                        var res = 0, i, len, af, bf, fieldName;
                        for (i = 0, len = fieldNames.length; i < len; i += 1) {
                            fieldName = fieldNames[i];
                            af = a[fieldName];
                            bf = b[fieldName];
                            if (af < bf)
                                res = -1 * mult;
                            else if (af > bf)
                                res = mult;
                            else
                                res = 0;

                            if (res !== 0)
                                return res;
                        }
                        return res;
                    };
                    this.sortLocalByFunc(fn_sort);
                }
                sortLocalByFunc(fn: (a, b) => number) {
                    var self = this;
                    this.waitForNotLoading(function () {
                        var cur = self.currentItem;
                        self.isLoading = true;
                        try {
                            self._items.sort(fn);
                            self._onItemsChanged({ change_type: COLL_CHANGE_TYPE.RESET, items: [], pos: [] });
                        } finally {
                            self.isLoading = false;
                        }
                        self.currentItem = null;
                        self.currentItem = cur;
                    }, [], false, null);
                }
                clear() {
                    this.raiseEvent('clearing', {});
                    this.cancelEdit();
                    this._EditingItem = null;
                    this._newKey = 0;
                    this.currentItem = null;
                    this._destroyItems();
                    this._items = [];
                    this._itemsByKey = {};
                    this._errors = {};
                    this._onItemsChanged({ change_type: COLL_CHANGE_TYPE.RESET, items: [], pos: [] });
                    this.raiseEvent('cleared', {});
                    this.raisePropertyChanged('count');
                }
                destroy() {
                    if (this._isDestroyed)
                        return;
                    this._isDestroyCalled = true;
                    this._waitQueue.destroy();
                    this._waitQueue = null;
                    this.clear();
                    this._fieldMap = {};
                    super.destroy();
                }
                waitForNotLoading(callback, callbackArgs: any[], syncCheck: boolean, groupName: string) {
                    this._waitQueue.enQueue({
                        prop: 'isLoading',
                        groupName: null,
                        predicate: function (val) {
                            return !val;
                        },
                        action: callback,
                        actionArgs: callbackArgs,
                        lastWins: !!groupName,
                        syncCheck: !!syncCheck
                    });
                }
                toString() {
                    return 'Collection';
                }
                get options() { return this._options; }
                get currentItem() { return this.getItemByPos(this._currentPos); }
                set currentItem(v: TItem) { this._setCurrentItem(v); }
                get count() { return this._items.length; }
                get totalCount() { return this._totalCount; }
                set totalCount(v: number) {
                    if (v != this._totalCount) {
                        this._totalCount = v;
                        this.raisePropertyChanged('totalCount');
                        this.raisePropertyChanged('pageCount');
                    }
                }
                get pageSize() { return this._options.pageSize; }
                set pageSize(v: number) {
                    if (this._options.pageSize !== v) {
                        this._options.pageSize = v;
                        this.raisePropertyChanged('pageSize');
                        this._onPageSizeChanged();
                    }
                }
                get pageIndex() { return this._pageIndex; }
                set pageIndex(v: number) {
                    if (v !== this._pageIndex && this.isPagingEnabled) {
                        if (v < 0)
                            return;
                        if (!this._onPageChanging()) {
                            return;
                        }
                        this._pageIndex = v;
                        this._onPageChanged();
                        this.raisePropertyChanged('pageIndex');
                    }
                }
                get items() { return this._items; }
                get isPagingEnabled() { return this._options.enablePaging; }
                get permissions() { return this._perms; }
                get isEditing() { return !!this._EditingItem; }
                get isLoading() { return this._isLoading; }
                set isLoading(v: boolean) {
                    if (this._isLoading !== v) {
                        this._isLoading = v;
                        this.raisePropertyChanged('isLoading');
                    }
                }
                get isUpdating() { return this._isUpdating; }
                set isUpdating(v: boolean) {
                    if (this._isUpdating !== v) {
                        this._isUpdating = v;
                        this.raisePropertyChanged('isUpdating');
                    }
                }
                get pageCount() {
                    var rowCount = this.totalCount, rowPerPage = this.pageSize, result: number;

                    if ((rowCount === 0) || (rowPerPage === 0)) {
                        return 0;
                    }

                    if ((rowCount % rowPerPage) === 0) {
                        result = (rowCount / rowPerPage);
                    }
                    else {
                        result = (rowCount / rowPerPage);
                        result = Math.floor(result) + 1;
                    }
                    return result;
                }
            }

            export class Collection extends BaseCollection<CollectionItem> { }

            export interface IPropInfo { name: string; dataType: number; }

            export class ListItem extends CollectionItem {
                __isNew: boolean;
                __coll: Collection;
                constructor(coll: BaseList<ListItem, any>, obj?: any) {
                    super();
                    var self = this;
                    this.__coll = coll;
                    this.__isNew = !obj;
                    //if object provided then all properties are exposed from the object
                    if (!!obj)
                        this._vals = obj;

                    if (!obj) { //if no object then fill values with nulls
                        this._collection.getFieldNames().forEach(function (name) {
                            self._vals[name] = null;
                        });
                    }
                }
                _setProp(name: string, val) {
                    var validation_error: binding.IValidationInfo, error, coll = this._collection;
                    if (this._vals[name] !== val) {
                        try {
                            this._vals[name] = val;
                            this.raisePropertyChanged(name);
                            coll._removeError(this, name);
                            validation_error = this._validateField(name);
                            if (!!validation_error) {
                                throw new ValidationError([validation_error], this);
                            }
                        } catch (ex) {
                            if (utils.check.isProtoOf(ValidationError, ex)) {
                                error = ex;
                            }
                            else {
                                error = new ValidationError([
                                    { fieldName: name, errors: [ex.message] }
                                ], this);
                            }
                            coll._addError(this, name, error.errors[0].errors);
                            throw error;
                        }
                    }
                }
                _getProp(name: string) {
                    return this._vals[name];
                }
                _resetIsNew() {
                    this.__isNew = false;
                }
                toString() {
                    return this._collection.toString() + 'Item';
                }
                get _isNew() { return this.__isNew; }
                get _collection() { return this.__coll; }
            }

            export interface IListItemConstructor<TItem extends ListItem, TObj> {
                new (coll: BaseList<TItem, TObj>, obj?: TObj): TItem;
            }

            export class BaseList<TItem extends ListItem, TObj> extends BaseCollection<TItem> {
                _type_name: string;
                _itemType: IListItemConstructor<TItem, TObj>;
                _props: string[];

                constructor(itemType: IListItemConstructor<TItem, TObj>, props:string[]) {
                    super();
                    this._type_name = 'BaseList';
                    this._itemType = itemType;
                    this._props = props;
                    if (!!this._props)
                        this._updateFieldMap();
                }
                _updateFieldMap() {
                    var self = this;
                    self._fieldMap = {};
                    this._props.forEach(function (prop) {
                        var fldInfo = BaseCollection.getEmptyFieldInfo(prop);
                        self._fieldMap[prop] = fldInfo;
                    });
                }
                _attach(item: TItem) {
                    try {
                        this.endEdit();
                    } catch (ex) {
                        global.reThrow(ex, this._onError(ex, this));
                    }
                    return super._attach(item);
                }
                _createNew() {
                    var item: CollectionItem = new this._itemType(this, null);
                    item._key = this._getNewKey(null); //client item ID
                    return item;
                }
                //here item parameter is not used, but can be used in descendants
                _getNewKey(item) {
                    var key = 'clkey_' + this._newKey; //client's item ID
                    this._newKey += 1;
                    return key;
                }
                fillItems(objArray: TObj[], clearAll?: boolean) {
                    var self = this, newItems = [], positions = [], fetchedItems = [];
                    this._onFillStart({ isBegin: true, rowCount: objArray.length, time: new Date(), isPageChanged: false });
                    try {
                        if (!!clearAll) this.clear();
                        objArray.forEach(function (obj) {
                            var item = new self._itemType(self,obj);
                            item._key = self._getNewKey(item);
                            var oldItem = self._itemsByKey[item._key];
                            if (!oldItem) {
                                self._items.push(item);
                                self._itemsByKey[item._key] = item;
                                newItems.push(item);
                                positions.push(self._items.length - 1);
                                fetchedItems.push(item);
                            }
                            else {
                                fetchedItems.push(oldItem);
                            }
                        });

                        if (newItems.length > 0) {
                            this._onItemsChanged({ change_type: COLL_CHANGE_TYPE.ADDED, items: newItems, pos: positions });
                            this.raisePropertyChanged('count');
                        }
                    }
                    finally {
                        this._onFillEnd({
                            isBegin: false, rowCount: fetchedItems.length, time: new Date(), resetUI: !!clearAll,
                            fetchedItems: fetchedItems, newItems: newItems, isPageChanged: false
                        });
                    }
                    this.moveFirst();
                }
                getNewObjects() {
                    return this._items.filter(function (item) {
                        return item._isNew;
                    });
                }
                resetNewObjects() {
                    this._items.forEach(function (item) {
                        item._resetIsNew();
                    });
                }
                toString() {
                    return this._type_name;
                }
            }

            export class BaseDictionary<TItem extends ListItem, TObj> extends BaseList<TItem, TObj>{
                _keyName: string;
                constructor(itemType: IListItemConstructor<TItem, TObj>, keyName: string, props: string[]) {
                    if (!keyName)
                        throw new Error(utils.format(RIAPP.ERRS.ERR_PARAM_INVALID, 'keyName', keyName));
                    this._keyName = keyName;
                    super(itemType, props);
                    var keyFld = this.getFieldInfo(keyName);
                    if (!keyFld)
                        throw new Error(utils.format(RIAPP.ERRS.ERR_DICTKEY_IS_NOTFOUND, keyName));
                    keyFld.isPrimaryKey = 1;
                }
                _getNewKey(item: TItem) {
                    if (!item) {
                        return super._getNewKey(null);
                    }
                    var key = item[this._keyName];
                    if (utils.check.isNt(key))
                        throw new Error(utils.format(RIAPP.ERRS.ERR_DICTKEY_IS_EMPTY, this._keyName));
                    return '' + key;
                }
            }
   
            export class List extends BaseList<ListItem, any> {
                constructor(type_name: string, properties: any) {
                    super(null,null);
                    this._type_name = type_name;
                    if (utils.check.isArray(properties)) {
                        this._props = properties;
                        if (this._props.length === 0)
                            throw new Error(utils.format(RIAPP.ERRS.ERR_PARAM_INVALID, 'properties', properties));
                        this._initFieldMap(false, properties);
                    }
                    else if (properties instanceof CollectionItem) {
                        //for properties which is collection item, we can obtain names by using getFieldNames();
                        this._props = properties.getFieldNames();
                        this._initFieldMap(true, properties);
                    }
                    else if (!!properties) {
                        //properties parameter is just simple object
                        //all its keys will be property names
                        this._props = Object.keys(properties);
                        this._initFieldMap(false, properties);
                    }
                    else
                        throw new Error(utils.format(RIAPP.ERRS.ERR_PARAM_INVALID, 'properties', properties));
                    this._itemType = null;
                    this._createItemType();
                }
                _initFieldMap(isCollectionItem: boolean, obj) {
                    var self = this;
                    if (!isCollectionItem) {
                        this._props.forEach(function (prop) {
                            self._fieldMap[prop] = BaseCollection.getEmptyFieldInfo(prop);
                        });
                    }
                    else {
                        this._props.forEach(function (prop) {
                            self._fieldMap[prop] = utils.extend(false, {}, obj.getFieldInfo(prop));
                        });
                    }
                }
                _createItemType() {
                    var propDescriptors = {}, self = this;
                    //create field accessor descriptor for each field
                    this.getFieldNames().forEach(function (name) {
                        propDescriptors[name] = {
                            set: function (x) {
                                this._setProp(name, x);
                            },
                            get: function () {
                                return this._getProp(name);
                            }
                        };
                    }, this);

                    this._itemType = <any>MOD.utils.__extendType(ListItem, {}, propDescriptors);
                }
            }

            export class Dictionary extends List {
                _keyName: string;
                constructor(type_name: string, properties: any, keyName: string) {
                    if (!keyName)
                        throw new Error(utils.format(RIAPP.ERRS.ERR_PARAM_INVALID, 'keyName', keyName));
                    this._keyName = keyName;
                    super(type_name, properties);
                    var keyFld = this.getFieldInfo(keyName);
                    if (!keyFld)
                        throw new Error(utils.format(RIAPP.ERRS.ERR_DICTKEY_IS_NOTFOUND, keyName));
                    keyFld.isPrimaryKey = 1;
                }
                _getNewKey(item: ListItem) {
                    if (!item) {
                        return super._getNewKey(null);
                    }
                    var key = item[this._keyName];
                    if (utils.check.isNt(key))
                        throw new Error(utils.format(RIAPP.ERRS.ERR_DICTKEY_IS_EMPTY, this._keyName));
                    return '' + key;
                }
            }

            global.registerType('List', List);
            global.registerType('Dictionary', Dictionary);
            global.onModuleLoaded('collection', collection);
        }
    }
}
