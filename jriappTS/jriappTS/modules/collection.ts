module RIAPP {
    export module MOD {
        export module collection {
            import constsMOD = RIAPP.MOD.consts;
            import utilsMOD = RIAPP.MOD.utils;
            import errorsMOD = RIAPP.MOD.errors;
            
            //local variables for optimization
            var ValidationError = errorsMOD.ValidationError,
                DATA_TYPE = constsMOD.DATA_TYPE, valueUtils = utilsMOD.valueUtils, baseUtils = RIAPP.baseUtils, utils: utilsMOD.Utils;
            RIAPP.global.addOnInitialize((s, args) => {
                utils = s.utils;
            });

            export enum FIELD_TYPE { None = 0, ClientOnly = 1, Calculated = 2, Navigation = 3, RowTimeStamp = 4, Object = 5, ServerCalculated = 6 }
            export enum STATUS { NONE= 0, ADDED= 1, UPDATED= 2, DELETED= 3 }
            export enum COLL_CHANGE_TYPE { REMOVE= 0, ADDED=1, RESET=2, REMAP_KEY=3 }
            export enum SORT_ORDER { ASC= 0, DESC= 1 }
            export enum FILTER_TYPE { Equals= 0, Between= 1, StartsWith= 2, EndsWith= 3, Contains= 4, Gt= 5, Lt= 6, GtEq= 7, LtEq= 8, NotEq= 9 }
          
            export interface IPermissions { canAddRow: boolean; canEditRow: boolean; canDeleteRow: boolean; canRefreshRow: boolean; }
            export interface IFieldInfo {
                fieldName: string;
                isPrimaryKey: number;
                dataType: constsMOD.DATA_TYPE;
                isNullable: boolean;
                isReadOnly: boolean;
                isAutoGenerated: boolean;
                isNeedOriginal: boolean;
                maxLength: number;
                dateConversion: constsMOD.DATE_CONVERSION;
                allowClientDefault: boolean;
                range: string;
                regex: string;
                fieldType: FIELD_TYPE;
                dependentOn: string;
                nested: IFieldInfo[];
                dependents?: string[];
                fullName?: string;
            }

            export function fn_getPropertyByName(name: string, props: IFieldInfo[]): IFieldInfo {
                var arrProps = props.filter((f) => { return f.fieldName == name; });
                if (!arrProps || arrProps.length != 1)
                    throw new Error(utils.format(RIAPP.ERRS.ERR_ASSERTION_FAILED, "arrProps.length == 1"));
                return arrProps[0];
            }

            export function fn_traverseField(fld: IFieldInfo, fn: (name: string, fld: IFieldInfo) => void) {
                function _fn_traverseField(name: string, fld: IFieldInfo, fn: (name: string, fld: IFieldInfo) => void) {
                    if (fld.fieldType == FIELD_TYPE.Object) {
                        fn(name, fld);
                        //for object fields traverse their nested properties
                        if (!!fld.nested && fld.nested.length > 0) {
                            var prop: IFieldInfo, i: number, len = fld.nested.length;
                            for (i = 0; i < len; i += 1) {
                                prop = fld.nested[i];
                                if (prop.fieldType == FIELD_TYPE.Object) {
                                    _fn_traverseField(name + '.' + prop.fieldName, prop, fn);
                                }
                                else {
                                    fn(name + '.' + prop.fieldName, prop);
                                }
                            }
                        }
                    }
                    else {
                        fn(name, fld);
                    }
                }
                _fn_traverseField(fld.fieldName, fld, fn);
            }

            export interface ICollectionItem extends RIAPP.IBaseObject {
                _aspect: ItemAspect<ICollectionItem>;
                _key: string;
            }
         
            export class ItemAspect<TItem extends ICollectionItem> extends RIAPP.BaseObject implements IErrorNotification, RIAPP.IEditable, RIAPP.ISubmittable {
                protected _fkey: string;
                protected _isEditing: boolean;
                protected _saveVals: { [fieldName: string]: any; };
                protected _vals: { [fieldName: string]: any; };
                protected _notEdited: boolean;

                constructor() {
                    super();
                    this._fkey = null;
                    this._isEditing = false;
                    this._saveVals = null;
                    this._vals = {};
                    this._notEdited = true;
                }
                protected _getEventNames() {
                    var base_events = super._getEventNames();
                    return ['errors_changed'].concat(base_events);
                }
                protected _onErrorsChanged(args: any) {
                    this.raiseEvent('errors_changed', args);
                }
                handleError(error, source): boolean {
                    var isHandled = super.handleError(error, source);
                    if (!isHandled) {
                        return this._collection.handleError(error, source);
                    }
                    return isHandled;
                }
                protected _beginEdit(): boolean {
                    var coll = this._collection, isHandled: boolean;
                    if (coll.isEditing) {
                        var eitem = coll._getEditingItem();
                        if (eitem._aspect === this)
                            return false;
                        try {
                            eitem._aspect.endEdit();
                            if (eitem._aspect.getIsHasErrors()) {
                                this.handleError(new ValidationError(eitem._aspect.getAllErrors(), eitem), eitem);
                                eitem._aspect.cancelEdit();
                            }
                        } catch (ex) {
                            isHandled = this.handleError(ex, eitem);
                            eitem._aspect.cancelEdit();
                            global.reThrow(ex, isHandled);
                        }
                    }
                    if (!this._key) //detached item
                        return false;
                    this._isEditing = true;
                    this._saveVals = utils.cloneObj(this._vals);
                    this._collection.currentItem = this.getItem();
                    return true;
                }
                protected _endEdit(): boolean {
                    if (!this._isEditing)
                        return false;
                    var coll = this._collection, self = this;
                    if (this.getIsHasErrors()) {
                        return false;
                    }
                    coll._removeAllErrors(this.getItem()); //revalidate all
                    var validation_errors = this._validateAll();
                    if (validation_errors.length > 0) {
                        coll._addErrors(self.getItem(), validation_errors);
                    }
                    if (this.getIsHasErrors()) {
                        return false;
                    }
                    this._isEditing = false;
                    this._saveVals = null;
                    return true;
                }
                protected _validate(): RIAPP.IValidationInfo {
                    return this._collection._validateItem(this.getItem());
                }
                protected _skipValidate(fieldInfo: IFieldInfo, val) {
                    return false;
                }
                protected _validateField(fieldName): RIAPP.IValidationInfo {
                    var val: any, fieldInfo = this.getFieldInfo(fieldName), res: RIAPP.IValidationInfo = null;
                    try {
                        val = baseUtils.getValue(this._vals,fieldName);
                        if (this._skipValidate(fieldInfo, val))
                            return res;
                        if (this._isNew) {
                            if (val === null && !fieldInfo.isNullable && !fieldInfo.isReadOnly && !fieldInfo.isAutoGenerated)
                                throw new Error(RIAPP.ERRS.ERR_FIELD_ISNOT_NULLABLE);
                        }
                        else {
                            if (val === null && !fieldInfo.isNullable && !fieldInfo.isReadOnly)
                                throw new Error(RIAPP.ERRS.ERR_FIELD_ISNOT_NULLABLE);
                        }
                    } catch (ex) {
                        res = { fieldName: fieldName, errors: [ex.message] };
                    }
                    var tmp = this._collection._validateItemField(this.getItem(), fieldName);
                    if (!!res && !!tmp) {
                        res.errors = res.errors.concat(tmp.errors);
                    }
                    else if (!!tmp)
                        res = tmp;
                    return res;
                }
                protected _validateAll(): RIAPP.IValidationInfo[] {
                    var self = this, fieldInfos = this._collection.getFieldInfos(), errs: RIAPP.IValidationInfo[] = [];
                    fieldInfos.forEach(function (fld) {
                        fn_traverseField(fld, (name, fld) => {
                            if (fld.fieldType != FIELD_TYPE.Object) {
                                var res = self._validateField(name);
                                if (!!res) {
                                    errs.push(res);
                                }
                            }
                        });
                    });

                    var res = self._validate();
                    if (!!res) {
                        errs.push(res);
                    }
                    return errs;
                }
                protected _checkVal(fieldInfo: IFieldInfo, val:any):any {
                    var res = val, ERRS = RIAPP.ERRS;
                    if (this._skipValidate(fieldInfo, val))
                        return res;
                    if (fieldInfo.isReadOnly && !(fieldInfo.allowClientDefault && this._isNew))
                        throw new Error(ERRS.ERR_FIELD_READONLY);
                    if ((val === null || (utils.check.isString(val) && !val)) && !fieldInfo.isNullable)
                        throw new Error(ERRS.ERR_FIELD_ISNOT_NULLABLE);

                    if (val === null)
                        return val;

                    switch (fieldInfo.dataType) {
                        case DATA_TYPE.None:
                            break;
                        case DATA_TYPE.Guid:
                        case DATA_TYPE.String:
                            if (!utils.check.isString(val)) {
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'String'));
                            }
                            if (fieldInfo.maxLength > 0 && val.length > fieldInfo.maxLength)
                                throw new Error(utils.format(ERRS.ERR_FIELD_MAXLEN, fieldInfo.maxLength));
                            if (fieldInfo.isNullable && val === '')
                                res = null;
                            if (!!fieldInfo.regex) {
                                var reg = new RegExp(fieldInfo.regex, "i");
                                if (!reg.test(val)) {
                                    throw new Error(utils.format(ERRS.ERR_FIELD_REGEX, val));
                                }
                            }
                            break;
                        case DATA_TYPE.Binary:
                            if (!utils.check.isArray(val)) {
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Array'));
                            }
                            if (fieldInfo.maxLength > 0 && val.length > fieldInfo.maxLength)
                                throw new Error(utils.format(ERRS.ERR_FIELD_MAXLEN, fieldInfo.maxLength));
                            break;
                        case DATA_TYPE.Bool:
                            if (!utils.check.isBoolean(val))
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Boolean'));
                            break;
                        case DATA_TYPE.Integer:
                        case DATA_TYPE.Decimal:
                        case DATA_TYPE.Float:
                            if (!utils.check.isNumber(val))
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Number'));
                            if (!!fieldInfo.range) {
                                utils.validation.checkNumRange(Number(val), fieldInfo.range);
                            }
                            break;
                        case DATA_TYPE.DateTime:
                        case DATA_TYPE.Date:
                            if (!utils.check.isDate(val))
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Date'));
                            if (!!fieldInfo.range) {
                                utils.validation.checkDateRange(val, fieldInfo.range);
                            }
                            break;
                        case DATA_TYPE.Time:
                            if (!utils.check.isDate(val))
                                throw new Error(utils.format(ERRS.ERR_FIELD_WRONG_TYPE, val, 'Time'));
                            break;
                        default:
                            throw new Error(utils.format(ERRS.ERR_PARAM_INVALID, 'dataType', fieldInfo.dataType));
                    }
                    return res;
                }
                protected _resetIsNew() {
                    //can reset _isNew on all items in the collection
                    //the list descendant does it
                }
                addOnErrorsChanged(fn: (sender: any, args: {}) => void, namespace?: string) {
                    this.addHandler('errors_changed', fn, namespace);
                }
                removeOnErrorsChanged(namespace?: string) {
                    this.removeHandler('errors_changed', namespace);
                }
                _onAttaching() {
                }
                _onAttach() {
                }
                raiseErrorsChanged(args: any) {
                    this._onErrorsChanged(args);
                }
                getFieldInfo(fieldName: string) {
                    return this._collection.getFieldInfo(fieldName);
                }
                getFieldNames() {
                    return this._collection.getFieldNames();
                }
                getFieldErrors(fieldName): RIAPP.IValidationInfo[] {
                    var itemErrors = this._collection._getErrors(this.getItem());
                    if (!itemErrors)
                        return [];
                    var name = fieldName;
                    if (!fieldName)
                        fieldName = '*';
                    if (!itemErrors[fieldName])
                        return [];
                    if (fieldName == '*')
                        name = null;
                    return [
                        { fieldName: name, errors: itemErrors[fieldName] }
                    ];
                }
                getAllErrors(): RIAPP.IValidationInfo[] {
                    var itemErrors = this._collection._getErrors(this.getItem());
                    if (!itemErrors)
                        return [];
                    var res: RIAPP.IValidationInfo[] = [];
                    utils.forEachProp(itemErrors, function (name) {
                        var fieldName = null;
                        if (name !== '*') {
                            fieldName = name;
                        }
                        res.push({ fieldName: fieldName, errors: itemErrors[name] });
                    });
                    return res;
                }
                getErrorString() {
                    var itemErrors = this._collection._getErrors(this.getItem());
                    if (!itemErrors)
                        return '';
                    var res = [];
                    utils.forEachProp(itemErrors, function (name) {
                        res.push(baseUtils.format('{0}: {1}', name, itemErrors[name]));
                    });
                    return res.join('|');
                }
                submitChanges(): IVoidPromise {
                    var deffered = utils.createDeferred();
                    deffered.reject();
                    return deffered.promise();
                }
                rejectChanges(): void {
                }
                beginEdit() {
                    var coll = this._collection;
                    if (!this._beginEdit())
                        return false;
                    coll._onEditing(this.getItem(), true, false);
                    this.raisePropertyChanged('isEditing');
                    return true;
                }
                endEdit() {
                    var coll = this._collection;
                    if (!this._endEdit())
                        return false;
                    coll._onEditing(this.getItem(), false, false);
                    this._notEdited = false;
                    this.raisePropertyChanged('isEditing');
                    return true;
                }
                cancelEdit() {
                    if (!this._isEditing)
                        return false;
                    var coll = this._collection, isNew = this._isNew;
                    var changes = this._saveVals;
                    this._vals = this._saveVals;
                    this._saveVals = null;
                    coll._removeAllErrors(this.getItem());
                    //refresh User interface when values restored
                    coll.getFieldNames().forEach(function (name) {
                        if (changes[name] !== this._vals[name])
                            this.raisePropertyChanged(name);
                    }, this);

                    if (isNew && this._notEdited)
                        coll.removeItem(this.getItem());

                    this._isEditing = false;
                    coll._onEditing(this.getItem(), false, true);
                    this.raisePropertyChanged('isEditing');
                    return true;
                }
                deleteItem() {
                    var coll = this._collection;
                    if (this._key === null)
                        return false;
                    if (!coll._onItemDeleting(this.getItem())) {
                        return false;
                    }
                    coll.removeItem(this.getItem());
                    return true;
                }
                getIsNew() {
                    return this._isNew;
                }
                getIsDeleted() {
                    return this._isDeleted;
                }
                getKey() {
                    return this._key;
                }
                getCollection() {
                    return this._collection;
                }
                getIsEditing() {
                    return this._isEditing;
                }
                getIsHasErrors() {
                    var itemErrors = this._collection._getErrors(this.getItem());
                    return !!itemErrors;
                }
                getIErrorNotification(): IErrorNotification {
                    return this;
                }
                destroy() {
                    if (this._isDestroyed)
                        return;
                    this._isDestroyCalled = true;
                    if (!!this._fkey && !!this._collection && !this._collection.getIsClearing()) {
                        this._collection.removeItem(this.getItem());
                    }
                    this._fkey = null;
                    this._saveVals = null;
                    this._vals = {};
                    this._isEditing = false;
                    super.destroy();
                }
                toString() {
                    return 'ItemAspect';
                }
                getItem(): TItem {
                    throw new Error('Not implemented');
                }
                get _isCanSubmit() { return false; }
                get _changeType() { return STATUS.NONE; }
                get _isNew() {
                    return false;
                }
                get _isDeleted() { return false; }
                get _key() { return this._fkey; }
                set _key(v) {
                    if (v !== null)
                        v = '' + v;
                    this._fkey = v;
                }
                get _collection(): BaseCollection<ICollectionItem> { return null; }
                get _isUpdating() {
                    var coll = this._collection;
                    if (!coll)
                        return false;
                    return coll.isUpdating;
                }
                get isEditing() { return this._isEditing; }
            }

            export interface ICollectionOptions {
                enablePaging: boolean; pageSize: number;
            }
            export interface ICollChangedArgs<TItem extends ICollectionItem> { change_type: COLL_CHANGE_TYPE; items: TItem[]; pos?: number[]; old_key?: string; new_key?: string; }
            export interface ICollFillArgs<TItem extends ICollectionItem> { isBegin: boolean; rowCount: number; time: Date; isPageChanged: boolean; resetUI?: boolean; fetchedItems?: TItem[]; newItems?: TItem[]; }
            export interface ICollValidateArgs<TItem extends ICollectionItem> { item: TItem; fieldName: string; errors: string[]; }
            export interface ICollItemStatusArgs<TItem extends ICollectionItem> { item: TItem; oldChangeType: STATUS; key: string; }
            export interface ICollItemAddedArgs<TItem extends ICollectionItem> { item: TItem; isAddNewHandled: boolean; }

          
            export class BaseCollection<TItem extends ICollectionItem> extends RIAPP.BaseObject {
                protected _options: ICollectionOptions;
                protected _isLoading: boolean;
                protected _EditingItem: TItem;
                protected _perms: IPermissions;
                protected _totalCount: number;
                protected _pageIndex: number;
                protected _items: TItem[];
                protected _itemsByKey: { [key: string]: TItem; };
                protected _currentPos: number;
                protected _newKey: number;
                protected _fieldMap: { [fieldName: string]: IFieldInfo; };
                protected _fieldInfos: IFieldInfo[];
                protected _errors: { [item_key: string]: { [fieldName: string]: string[]; }; };
                protected _ignoreChangeErrors: boolean;
                protected _pkInfo: IFieldInfo[];
                protected _isUpdating: boolean;
                protected _isClearing: boolean;
                protected _waitQueue: utilsMOD.WaitQueue;

                constructor() {
                    super();
                    this._options = { enablePaging: false, pageSize: 50 };
                    this._isLoading = false;
                    this._isClearing = false;
                    this._isUpdating = false;

                    this._EditingItem = null;
                    this._perms = { canAddRow: true, canEditRow: true, canDeleteRow: true, canRefreshRow: false };
                    //includes stored on server
                    this._totalCount = 0;
                    this._pageIndex = 0;
                    this._items = [];
                    this._itemsByKey = {};
                    this._currentPos = -1;
                    this._newKey = 0;
                    this._fieldMap = {};
                    this._fieldInfos = [];
                    this._errors = {};
                    this._ignoreChangeErrors = false;
                    this._pkInfo = null;
                    this._waitQueue = new utilsMOD.WaitQueue(this);
                }

                static getEmptyFieldInfo(fieldName: string) {
                    var fieldInfo: IFieldInfo = {
                        fieldName: fieldName,
                        isPrimaryKey: 0,
                        dataType: DATA_TYPE.None,
                        isNullable: true,
                        maxLength: -1,
                        isReadOnly: false,
                        isAutoGenerated: false,
                        allowClientDefault: false,
                        dateConversion: constsMOD.DATE_CONVERSION.None,
                        fieldType: FIELD_TYPE.ClientOnly,
                        isNeedOriginal: false,
                        range: null,
                        regex: null,
                        nested: null,
                        dependentOn: null,
                        fullName: null
                    };
                    return fieldInfo;
                }
                protected _getEventNames() {
                    var base_events = super._getEventNames();
                    return ['begin_edit', 'end_edit', 'fill', 'coll_changed', 'item_deleting', 'item_adding', 'item_added',
                        'validate', 'current_changing', 'page_changing', 'errors_changed', 'status_changed', 'clearing',
                        'cleared', 'commit_changes'].concat(base_events);
                }
                handleError(error, source): boolean {
                    var isHandled = super.handleError(error, source);
                    if (!isHandled) {
                        return global.handleError(error, source);
                    }
                    return isHandled;
                }
                addOnClearing(fn: (sender: BaseCollection<TItem>, args: {}) => void, namespace?: string) {
                    this.addHandler('clearing', fn, namespace);
                }
                removeOnClearing(namespace?: string) {
                    this.removeHandler('clearing', namespace);
                }
                addOnCleared(fn: (sender: BaseCollection<TItem>, args: {}) => void, namespace?: string) {
                    this.addHandler('cleared', fn, namespace);
                }
                removeOnCleared(namespace?: string) {
                    this.removeHandler('cleared', namespace);
                }
                addOnFill(fn: (sender: BaseCollection<TItem>, args: ICollFillArgs<TItem>) => void, namespace?: string) {
                    this.addHandler('fill', fn, namespace);
                }
                removeOnFill(namespace?: string) {
                    this.removeHandler('fill', namespace);
                }
                addOnCollChanged(fn: (sender: BaseCollection<TItem>, args: ICollChangedArgs<TItem>) => void, namespace?: string) {
                    this.addHandler('coll_changed', fn, namespace);
                }
                removeOnCollChanged(namespace?: string) {
                    this.removeHandler('coll_changed', namespace);
                }
                addOnValidate(fn: (sender: BaseCollection<TItem>, args: ICollValidateArgs<TItem>) => void, namespace?: string) {
                    this.addHandler('validate', fn, namespace);
                }
                removeOnValidate(namespace?: string) {
                    this.removeHandler('validate', namespace);
                }
                addOnItemDeleting(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isCancel: boolean; }) => void, namespace?: string) {
                    this.addHandler('item_deleting', fn, namespace);
                }
                removeOnItemDeleting(namespace?: string) {
                    this.removeHandler('item_deleting', namespace);
                }
                addOnItemAdding(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isCancel: boolean; }) => void, namespace?: string) {
                    this.addHandler('item_adding', fn, namespace);
                }
                removeOnItemAdding(namespace?: string) {
                    this.removeHandler('item_adding', namespace);
                }
                addOnItemAdded(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isAddNewHandled: boolean; }) => void, namespace?: string) {
                    this.addHandler('item_added', fn, namespace);
                }
                removeOnItemAdded(namespace?: string) {
                    this.removeHandler('item_added', namespace);
                }
                addOnCurrentChanging(fn: (sender: BaseCollection<TItem>, args: { newCurrent: TItem; }) => void, namespace?: string) {
                    this.addHandler('current_changing', fn, namespace);
                }
                removeOnCurrentChanging(namespace?: string) {
                    this.removeHandler('current_changing', namespace);
                }
                addOnPageChanging(fn: (sender: BaseCollection<TItem>, args: { page: number; isCancel: boolean; }) => void, namespace?: string) {
                    this.addHandler('page_changing', fn, namespace);
                }
                removeOnPageChanging(namespace?: string) {
                    this.removeHandler('page_changing', namespace);
                }
                addOnErrorsChanged(fn: (sender: BaseCollection<TItem>, args: { item: TItem; }) => void, namespace?: string) {
                    this.addHandler('errors_changed', fn, namespace);
                }
                removeOnErrorsChanged(namespace?: string) {
                    this.removeHandler('errors_changed', namespace);
                }
                addOnBeginEdit(fn: (sender: BaseCollection<TItem>, args: { item: TItem; }) => void, namespace?: string) {
                    this.addHandler('begin_edit', fn, namespace);
                }
                removeOnBeginEdit(namespace?: string) {
                    this.removeHandler('begin_edit', namespace);
                }
                addOnEndEdit(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isCanceled: boolean; }) => void, namespace?: string) {
                    this.addHandler('end_edit', fn, namespace);
                }
                removeOnEndEdit(namespace?: string) {
                    this.removeHandler('end_edit', namespace);
                }
                addOnCommitChanges(fn: (sender: BaseCollection<TItem>, args: { item: TItem; isBegin: boolean; isRejected: boolean; changeType: number; }) => void, namespace?: string) {
                    this.addHandler('commit_changes', fn, namespace);
                }
                removeOnCommitChanges(namespace?: string) {
                    this.removeHandler('commit_changes', namespace);
                }
                addOnStatusChanged(fn: (sender: BaseCollection<TItem>, args: ICollItemStatusArgs<TItem>) => void, namespace?: string) {
                    this.addHandler('status_changed', fn, namespace);
                }
                removeOnStatusChanged(namespace?: string) {
                    this.removeHandler('status_changed', namespace);
                }
                protected _getPKFieldInfos(): IFieldInfo[] {
                    if (!!this._pkInfo)
                        return this._pkInfo;
                    var fldMap = this._fieldMap, pk = [];
                    utils.forEachProp(fldMap, function (fldName) {
                        if (fldMap[fldName].isPrimaryKey > 0) {
                            pk.push(fldMap[fldName]);
                        }
                    });
                    pk.sort(function (a, b) {
                        return a.isPrimaryKey - b.isPrimaryKey;
                    });
                    this._pkInfo = pk;
                    return this._pkInfo;
                }
                protected _onCurrentChanging(newCurrent: TItem) {
                    try {
                        this.endEdit();
                    } catch (ex) {
                        global.reThrow(ex, this.handleError(ex, this));
                    }
                    this.raiseEvent('current_changing', { newCurrent: newCurrent });
                }
                protected _onCurrentChanged() {
                    this.raisePropertyChanged('currentItem');
                }
                //occurs when item changeType Changed (not used in simple collections)
                protected _onItemStatusChanged(item: TItem, oldChangeType: number) {
                    this.raiseEvent('status_changed', { item: item, oldChangeType: oldChangeType, key: item._key });
                }
                protected _onFillStart(args: { isBegin: boolean; rowCount: number; time: Date; isPageChanged: boolean; }) {
                    this.raiseEvent('fill', args);
                }
                protected _onFillEnd(args: { isBegin: boolean; rowCount: number; time: Date; isPageChanged: boolean; resetUI: boolean; fetchedItems: TItem[]; newItems: TItem[]; }) {
                    this.raiseEvent('fill', args);
                }
                protected _onItemsChanged(args: { change_type: COLL_CHANGE_TYPE; items: TItem[]; pos?: number[]; old_key?: string; new_key?: string; }) {
                    this.raiseEvent('coll_changed', args);
                }
                //new item is being added, but is not in the collection now
                protected _onItemAdding(item: TItem) {
                    var args = { item: item, isCancel: false };
                    this.raiseEvent('item_adding', args);
                    if (args.isCancel)
                        global._throwDummy(new Error('operation canceled'));
                }
                //new item has been added and now is in editing state and is currentItem
                protected _onItemAdded(item: TItem) {
                    var args = { item: item, isAddNewHandled: false };
                    this.raiseEvent('item_added', args);
                }
                protected _createNew(): TItem {
                    throw new Error('_createNew Not implemented');
                }
                protected _attach(item: TItem, itemPos?: number) {
                    if (!!this._itemsByKey[item._key]) {
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_ATTACHED);
                    }
                    try {
                        this.endEdit();
                    } catch (ex) {
                        global.reThrow(ex, this.handleError(ex, this));
                    }
                    var pos;
                    item._aspect._onAttaching();
                    if (utils.check.isNt(itemPos)) {
                        pos = this._items.length;
                        this._items.push(item);
                    }
                    else {
                        pos = itemPos;
                        utils.insertIntoArray(this._items, item, pos);
                    }
                    this._itemsByKey[item._key] = item;
                    this._onItemsChanged({ change_type: COLL_CHANGE_TYPE.ADDED, items: [item], pos: [pos] });
                    item._aspect._onAttach();
                    this.raisePropertyChanged('count');
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return pos;
                }
                protected _onRemoved(item: TItem, pos: number) {
                    try {
                        this._onItemsChanged({ change_type: COLL_CHANGE_TYPE.REMOVE, items: [item], pos: [pos] });
                    }
                    finally {
                        this.raisePropertyChanged('count');
                    }
                }
                protected _onPageSizeChanged() {
                }
                protected _onPageChanging() {
                    var args = { page: this.pageIndex, isCancel: false };
                    this._raiseEvent('page_changing', args);
                    if (!args.isCancel) {
                        try {
                            this.endEdit();
                        } catch (ex) {
                            global.reThrow(ex, this.handleError(ex, this));
                        }
                    }
                    return !args.isCancel;
                }
                protected _onPageChanged() {
                }
                protected _setCurrentItem(v: TItem) {
                    var self = this, oldPos = self._currentPos;
                    if (!v) {
                        if (oldPos !== -1) {
                            self._onCurrentChanging(null);
                            self._currentPos = -1;
                            self._onCurrentChanged();
                        }
                        return;
                    }
                    if (!v._key)
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_DETACHED);
                    var oldItem, pos, item = self.getItemByKey(v._key);
                    if (!item) {
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_NOTFOUND);
                    }
                    oldItem = self.getItemByPos(oldPos);
                    pos = self._items.indexOf(v);
                    if (pos < 0)
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_NOTFOUND);
                    if (oldPos !== pos || oldItem !== v) {
                        self._onCurrentChanging(v);
                        self._currentPos = pos;
                        self._onCurrentChanged();
                    }
                }
                protected _destroyItems() {
                    this._items.forEach(function (item) {
                        item._aspect.destroy();
                    });
                }
                protected _isHasProp(prop: string) {
                    //first check for indexed property name
                    if (baseUtils.startsWith(prop, '[')) {
                        var res = global.parser.resolveProp(this, prop);
                        return !baseUtils.isUndefined(res);
                    }
                    return super._isHasProp(prop);
                }
                _getEditingItem() {
                    return this._EditingItem;
                }
                _getStrValue(val, fieldInfo: IFieldInfo) {
                    var dcnv = fieldInfo.dateConversion, stz = utils.get_timeZoneOffset();
                    return valueUtils.stringifyValue(val, dcnv, fieldInfo.dataType, stz);
                }
                _onEditing(item: TItem, isBegin: boolean, isCanceled: boolean) {
                    if (this._isUpdating)
                        return;
                    if (isBegin) {
                        this._EditingItem = item;
                        this.raiseEvent('begin_edit', { item: item });
                    }
                    else {
                        this._EditingItem = null;
                        this.raiseEvent('end_edit', { item: item, isCanceled: isCanceled });
                    }
                }
                //used by descendants when commiting submits for items
                _onCommitChanges(item: TItem, isBegin: boolean, isRejected: boolean, changeType: number) {
                    this.raiseEvent('commit_changes', { item: item, isBegin: isBegin, isRejected: isRejected, changeType: changeType });
                }
                _validateItem(item: TItem): RIAPP.IValidationInfo {
                    var args = { item: item, fieldName: null, errors: [] };
                    this.raiseEvent('validate', args);
                    if (!!args.errors && args.errors.length > 0)
                        return { fieldName: null, errors: args.errors };
                    else
                        return null;
                }
                _validateItemField(item: TItem, fieldName: string): RIAPP.IValidationInfo {
                    var args = { item: item, fieldName: fieldName, errors: [] };
                    this.raiseEvent('validate', args);
                    if (!!args.errors && args.errors.length > 0)
                        return { fieldName: fieldName, errors: args.errors };
                    else
                        return null;
                }
                _addErrors(item: TItem, errors: RIAPP.IValidationInfo[]) {
                    var self = this;
                    this._ignoreChangeErrors = true;
                    try {
                        errors.forEach(function (err) {
                            self._addError(item, err.fieldName, err.errors);
                        });
                    } finally {
                        this._ignoreChangeErrors = false;
                    }
                    this._onErrorsChanged(item);
                }
                _addError(item: TItem, fieldName: string, errors: string[]) {
                    if (!fieldName)
                        fieldName = '*';
                    if (!(utils.check.isArray(errors) && errors.length > 0)) {
                        this._removeError(item, fieldName);
                        return;
                    }
                    if (!this._errors[item._key])
                        this._errors[item._key] = {};
                    var itemErrors = this._errors[item._key];
                    itemErrors[fieldName] = errors;
                    if (!this._ignoreChangeErrors)
                        this._onErrorsChanged(item);
                }
                _removeError(item: TItem, fieldName: string) {
                    var itemErrors = this._errors[item._key];
                    if (!itemErrors)
                        return;
                    if (!fieldName)
                        fieldName = '*';
                    if (!itemErrors[fieldName])
                        return;
                    delete itemErrors[fieldName];
                    if (utils.getProps(itemErrors).length === 0) {
                        delete this._errors[item._key];
                    }
                    this._onErrorsChanged(item);
                }
                _removeAllErrors(item: TItem) {
                    var self = this, itemErrors = this._errors[item._key];
                    if (!itemErrors)
                        return;
                    delete this._errors[item._key];
                    self._onErrorsChanged(item);
                }
                _getErrors(item: TItem): { [fieldName: string]: string[]; } {
                    return this._errors[item._key];
                }
                _onErrorsChanged(item: TItem) {
                    var args = { item: item };
                    this.raiseEvent('errors_changed', args);
                    item._aspect.raiseErrorsChanged({});
                }
                _onItemDeleting(item: TItem) {
                    var args = { item: item, isCancel: false };
                    this.raiseEvent('item_deleting', args);
                    return !args.isCancel;
                }
                getFieldInfo(fieldName: string): IFieldInfo {
                    var parts = fieldName.split('.'), fld = this._fieldMap[parts[0]];
                    if (parts.length == 1) {
                        return fld;
                    }
                    if (fld.fieldType == FIELD_TYPE.Object) {
                        for (var i = 1; i < parts.length; i += 1) {
                            fld = fn_getPropertyByName(parts[i], fld.nested);
                        }
                        return fld;
                    }
                    throw new Error(baseUtils.format(RIAPP.ERRS.ERR_PARAM_INVALID, 'fieldName', fieldName));
                }
                getFieldNames(): string[] {
                    return this.getFieldInfos().map((f) => {
                        return f.fieldName;
                    });
                }
                getIsClearing(): boolean {
                    return this._isClearing;
                }
                getFieldInfos(): IFieldInfo[] {
                    return this._fieldInfos;
                }
                cancelEdit() {
                    if (this.isEditing)
                        this._EditingItem._aspect.cancelEdit();
                }
                endEdit() {
                    var EditingItem;
                    if (this.isEditing) {
                        EditingItem = this._EditingItem;
                        if (!EditingItem.endEdit() && EditingItem.getIsHasErrors()) {
                            this.handleError(new ValidationError(EditingItem.getAllErrors(), EditingItem), EditingItem);
                            this.cancelEdit();
                        }
                    }
                }
                getItemsWithErrors(): TItem[] {
                    var self = this, res: TItem[] = [];
                    utils.forEachProp(this._errors, function (key) {
                        var item = self.getItemByKey(key);
                        res.push(item);
                    });
                    return res;
                }
                addNew() {
                    var item: TItem, isHandled: boolean;
                    item = this._createNew();
                    this._onItemAdding(item);
                    this._attach(item, null);
                    try {
                        this.currentItem = item;
                        item._aspect.beginEdit();
                        this._onItemAdded(item);
                    }
                    catch (ex) {
                        isHandled = this.handleError(ex, this);
                        item._aspect.cancelEdit();
                        global.reThrow(ex, isHandled);
                    }
                    return item;
                }
                getItemByPos(pos: number): TItem {
                    if (pos < 0 || pos >= this._items.length)
                        return null;
                    return this._items[pos];
                }
                getItemByKey(key: string): TItem {
                    if (!key)
                        throw new Error(RIAPP.ERRS.ERR_KEY_IS_EMPTY);
                    var map = this._itemsByKey;
                    return map['' + key];
                }
                findByPK(...vals: any[]): TItem {
                    if (arguments.length === 0)
                        return null;
                    var self = this, pkInfo = self._getPKFieldInfos(), arr = [], key, values = [];
                    if (vals.length === 1 && utils.check.isArray(vals[0])) {
                        values = vals[0];
                    }
                    else
                        values = vals;
                    if (values.length !== pkInfo.length) {
                        return null;
                    }
                    for (var i = 0, len = pkInfo.length; i < len; i += 1) {
                        arr.push(self._getStrValue(values[i], pkInfo[i]));
                    }

                    key = arr.join(';');
                    return self.getItemByKey(key);
                }
                moveFirst(skipDeleted?: boolean): boolean {
                    var pos = 0, old = this._currentPos;
                    if (old === pos)
                        return false;
                    var item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    if (!!skipDeleted) {
                        if (item._aspect._isDeleted) {
                            return this.moveNext(true);
                        }
                    }
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                movePrev(skipDeleted?: boolean): boolean {
                    var pos = -1, old = this._currentPos;
                    var item = this.getItemByPos(old);
                    if (!!item) {
                        pos = old;
                        pos -= 1;
                    }
                    item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    if (!!skipDeleted) {
                        if (item._aspect._isDeleted) {
                            this._currentPos = pos;
                            return this.movePrev(true);
                        }
                    }
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                moveNext(skipDeleted?: boolean): boolean {
                    var pos = -1, old = this._currentPos;
                    var item = this.getItemByPos(old);
                    if (!!item) {
                        pos = old;
                        pos += 1;
                    }
                    item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    if (!!skipDeleted) {
                        if (item._aspect._isDeleted) {
                            this._currentPos = pos;
                            return this.moveNext(true);
                        }
                    }
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                moveLast(skipDeleted?: boolean): boolean {
                    var pos = this._items.length - 1, old = this._currentPos;
                    if (old === pos)
                        return false;
                    var item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    if (!!skipDeleted) {
                        if (item._aspect._isDeleted) {
                            return this.movePrev(true);
                        }
                    }
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                goTo(pos: number): boolean {
                    var old = this._currentPos;
                    if (old === pos)
                        return false;
                    var item = this.getItemByPos(pos);
                    if (!item)
                        return false;
                    this._onCurrentChanging(item);
                    this._currentPos = pos;
                    this._onCurrentChanged();
                    return true;
                }
                forEach(callback: (item: TItem) => void, thisObj?: any) {
                    this._items.forEach(callback, thisObj);
                }
                removeItem(item: TItem) {
                    if (item._key === null) {
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_DETACHED);
                    }
                    if (!this._itemsByKey[item._key])
                        return;
                    var oldPos = utils.removeFromArray(this._items, item);
                    if (oldPos < 0) {
                        throw new Error(RIAPP.ERRS.ERR_ITEM_IS_NOTFOUND);
                    }
                    delete this._itemsByKey[item._key];
                    delete this._errors[item._key];
                    this._onRemoved(item, oldPos);
                    item._key = null;
                    item._aspect.removeNSHandlers(null);
                    var test = this.getItemByPos(oldPos), curPos = this._currentPos;

                    //if detached item was current item
                    if (curPos === oldPos) {
                        if (!test) { //it was the last item
                            this._currentPos = curPos - 1;
                        }
                        this._onCurrentChanged();
                    }

                    if (curPos > oldPos) {
                        this._currentPos = curPos - 1;
                        this._onCurrentChanged();
                    }
                }
                getIsHasErrors(): boolean {
                    if (!this._errors)
                        return false;
                    return (utils.getProps(this._errors).length > 0);
                }
                sort(fieldNames: string[], sortOrder: SORT_ORDER): IPromise<any> {
                    return this.sortLocal(fieldNames, sortOrder);
                }
                sortLocal(fieldNames: string[], sortOrder: SORT_ORDER): IPromise<any>  {
                    var self = this;
                    var mult = 1;
                    if (sortOrder === SORT_ORDER.DESC)
                        mult = -1;
                    var fn_sort = function (a, b) {
                        var res = 0, i, len, af, bf, fieldName;
                        for (i = 0, len = fieldNames.length; i < len; i += 1) {
                            fieldName = fieldNames[i];
                            af = a[fieldName];
                            bf = b[fieldName];
                            if (af < bf)
                                res = -1 * mult;
                            else if (af > bf)
                                res = mult;
                            else
                                res = 0;

                            if (res !== 0)
                                return res;
                        }
                        return res;
                    };
                    return self.sortLocalByFunc(fn_sort);
                }
                sortLocalByFunc(fn: (a, b) => number): IPromise<any> {
                    var self = this, deffered = utils.createDeferred();
                    this.waitForNotLoading(function () {
                        var cur = self.currentItem;
                        self.isLoading = true;
                        try {
                            self._items.sort(fn);
                            self._onItemsChanged({ change_type: COLL_CHANGE_TYPE.RESET, items: [], pos: [] });
                        } finally {
                            self.isLoading = false;
                            deffered.resolve();
                        }
                        self.currentItem = null;
                        self.currentItem = cur;
                    }, [], false, null);

                    return deffered.promise();
                }
                clear() {
                    this._isClearing = true;
                    try {
                        this.raiseEvent('clearing', {});
                        this.cancelEdit();
                        this._EditingItem = null;
                        this._newKey = 0;
                        this.currentItem = null;
                        this._destroyItems();
                        this._items = [];
                        this._itemsByKey = {};
                        this._errors = {};
                        this._onItemsChanged({ change_type: COLL_CHANGE_TYPE.RESET, items: [], pos: [] });
                    }
                    finally {
                        this._isClearing = false;
                    }
                    this.raiseEvent('cleared', {});
                    this.raisePropertyChanged('count');
                }
                destroy() {
                    if (this._isDestroyed)
                        return;
                    this._isDestroyCalled = true;
                    this._waitQueue.destroy();
                    this._waitQueue = null;
                    this.clear();
                    this._fieldMap = {};
                    this._fieldInfos = [];
                    super.destroy();
                }
                waitForNotLoading(callback, callbackArgs: any[], syncCheck: boolean, groupName: string) {
                    this._waitQueue.enQueue({
                        prop: 'isLoading',
                        groupName: null,
                        predicate: function (val) {
                            return !val;
                        },
                        action: callback,
                        actionArgs: callbackArgs,
                        lastWins: !!groupName,
                        syncCheck: !!syncCheck
                    });
                }
                toString() {
                    return 'Collection';
                }
                get options() { return this._options; }
                get currentItem() { return this.getItemByPos(this._currentPos); }
                set currentItem(v: TItem) { this._setCurrentItem(v); }
                get count() { return this._items.length; }
                get totalCount() { return this._totalCount; }
                set totalCount(v: number) {
                    if (v != this._totalCount) {
                        this._totalCount = v;
                        this.raisePropertyChanged('totalCount');
                        this.raisePropertyChanged('pageCount');
                    }
                }
                get pageSize() { return this._options.pageSize; }
                set pageSize(v: number) {
                    if (this._options.pageSize !== v) {
                        this._options.pageSize = v;
                        this.raisePropertyChanged('pageSize');
                        this._onPageSizeChanged();
                    }
                }
                get pageIndex() { return this._pageIndex; }
                set pageIndex(v: number) {
                    if (v !== this._pageIndex && this.isPagingEnabled) {
                        if (v < 0)
                            return;
                        if (!this._onPageChanging()) {
                            return;
                        }
                        this._pageIndex = v;
                        this._onPageChanged();
                        this.raisePropertyChanged('pageIndex');
                    }
                }
                get items() { return this._items; }
                get isPagingEnabled() { return this._options.enablePaging; }
                get permissions() { return this._perms; }
                get isEditing() { return !!this._EditingItem; }
                get isLoading() { return this._isLoading; }
                set isLoading(v: boolean) {
                    if (this._isLoading !== v) {
                        this._isLoading = v;
                        this.raisePropertyChanged('isLoading');
                    }
                }
                get isUpdating() { return this._isUpdating; }
                set isUpdating(v: boolean) {
                    if (this._isUpdating !== v) {
                        this._isUpdating = v;
                        this.raisePropertyChanged('isUpdating');
                    }
                }
                get pageCount() {
                    var rowCount = this.totalCount, rowPerPage = this.pageSize, result: number;

                    if ((rowCount === 0) || (rowPerPage === 0)) {
                        return 0;
                    }

                    if ((rowCount % rowPerPage) === 0) {
                        result = (rowCount / rowPerPage);
                    }
                    else {
                        result = (rowCount / rowPerPage);
                        result = Math.floor(result) + 1;
                    }
                    return result;
                }
            }

            export interface IListItem extends ICollectionItem {
                _aspect: ListItemAspect<IListItem, any>;
            }
            export interface IListItemAspectConstructor<TItem extends IListItem, TObj> {
                new (coll: BaseList<TItem, TObj>, itemType: IListItemConstructor<TItem, TObj>,  obj?: TObj): ListItemAspect<TItem, TObj>;
            }
            export interface IListItemConstructor<TItem extends IListItem, TObj> {
                new (aspect: ListItemAspect<TItem, TObj>): TItem;
            }
            export interface IPropInfo { name: string; dtype: number; }

            export class CollectionItem<TAspect extends ItemAspect<ICollectionItem>> extends RIAPP.BaseObject implements ICollectionItem {
                private f_aspect: TAspect;
                constructor(aspect:TAspect) {
                    super();
                    this.f_aspect = aspect;
                }
                get _aspect() { return this.f_aspect; }
                get _key() { return !!this.f_aspect ? this.f_aspect._key : null; }
                destroy() {
                    if (this._isDestroyed)
                        return;
                    this._isDestroyCalled = true;
                    if (!!this.f_aspect && !this.f_aspect.getIsDestroyCalled()) {
                        this.f_aspect.destroy();
                    }
                    //this.f_aspect = null;
                    super.destroy();
                }
                toString() {
                    return 'CollectionItem';
                }
            }

            export class ListItemAspect<TItem extends IListItem, TObj> extends ItemAspect<TItem> {
                protected __isNew: boolean;
                protected __coll: BaseList<IListItem, TObj>;
                protected _item: TItem;
              
                constructor(coll: BaseList<IListItem, TObj>, itemType: IListItemConstructor<TItem, TObj>, obj?: TObj) {
                    super();
                    var self = this;
                    this.__coll = coll;
                    this.__isNew = !obj ? true : false;
                    this._item = null;
                    if (!!obj)
                        this._vals = <any>obj;
                    else
                        this._vals = ListItemAspect._initVals(coll, obj);
                    this._item = new itemType(this);
                }
                protected static _initVals(coll: BaseList<IListItem, any>, obj?: any): any {
                    var vals = obj || {};
                    if (!!obj) {
                        //if no object then set all values to nulls
                        var fieldInfos = coll.getFieldInfos();
                        fieldInfos.forEach(function (fld) {
                            if (fld.fieldType != FIELD_TYPE.Object) {
                                vals[fld.fieldName] = null;
                            }
                            else {
                                //object field
                                fn_traverseField(fld, (name, fld) => {
                                    if (fld.fieldType == FIELD_TYPE.Object)
                                        baseUtils.setValue(vals, name, {}, false);
                                    else
                                        baseUtils.setValue(vals, name, null, false);
                                });
                            }
                        });
                    }
                    return vals;
                }
                _setProp(name: string, val) {
                    var validation_error: RIAPP.IValidationInfo, error: errorsMOD.ValidationError, coll = this._collection;
                    if (this._getProp(name) !== val) {
                        try {
                            baseUtils.setValue(this._vals, name, val, false);
                            this.getItem().raisePropertyChanged(name);
                            coll._removeError(this.getItem(), name);
                            validation_error = this._validateField(name);
                            if (!!validation_error) {
                                throw new ValidationError([validation_error], this);
                            }
                        } catch (ex) {
                            if (ex instanceof ValidationError) {
                                error = ex;
                            }
                            else {
                                error = new ValidationError([
                                    { fieldName: name, errors: [ex.message] }
                                ], this);
                            }
                            coll._addError(this.getItem(), name, error.errors[0].errors);
                            throw error;
                        }
                    }
                }
                _getProp(name: string) {
                    return baseUtils.getValue(this._vals, name);
                }
                _resetIsNew() {
                    this.__isNew = false;
                }
                destroy() {
                    if (this._isDestroyed)
                        return;
                    this._isDestroyCalled = true;
                    if (!!this._item && !this._item.getIsDestroyCalled()) {
                        this._item.destroy();
                    }
                    this._item = null;
                    super.destroy();
                }
                getItem(): TItem {
                    return this._item;
                }
                toString() {
                    if (!this._item)
                        return 'ListItemAspect';
                    return this._item.toString() + 'Aspect';
                }
                get vals() { return this._vals; }
                get _isNew() { return this.__isNew; }
                get _collection() { return this.__coll; }
            }

            export class BaseList<TItem extends IListItem, TObj> extends BaseCollection<TItem> {
                protected _itemType: IListItemConstructor<TItem, TObj>;
                constructor(itemType: IListItemConstructor<TItem, TObj>, props: IPropInfo[]) {
                    super();
                    this._itemType = itemType;
                    if (!!props)
                        this._updateFieldMap(props);
                }
                private _updateFieldMap(props: IPropInfo[]) {
                    var self = this;
                    if (!utils.check.isArray(props) || props.length == 0)
                        throw new Error(baseUtils.format(RIAPP.ERRS.ERR_PARAM_INVALID, 'props', props));

                    self._fieldMap = {};
                    self._fieldInfos = [];
                    props.forEach(function (prop) {
                        var fldInfo = BaseCollection.getEmptyFieldInfo(prop.name);
                        fldInfo.dataType = prop.dtype; 
                        self._fieldMap[prop.name] = fldInfo;
                        self._fieldInfos.push(fldInfo);
                        fn_traverseField(fldInfo, (fullName, fld) => {
                            fld.dependents = null;
                            fld.fullName = fullName;
                        });
                    });
                }
                protected _attach(item: TItem) {
                    try {
                        this.endEdit();
                    } catch (ex) {
                        global.reThrow(ex, this.handleError(ex, this));
                    }
                    return super._attach(item);
                }
                protected _createNew(): TItem {
                    var aspect = new ListItemAspect<TItem, TObj>(this, this._itemType, null);
                    //a new client item ID
                    aspect._key = this._getNewKey(null);
                    return aspect.getItem();
                }
                //the item parameter is not used here, but can be used in descendants
                protected _getNewKey(item) {
                    //client's item ID
                    var key = 'clkey_' + this._newKey; 
                    this._newKey += 1;
                    return key;
                }
                destroy() {
                    if (this._isDestroyed)
                        return;
                    this._isDestroyCalled = true;
                    this._itemType = null;
                    super.destroy();
                }
                fillItems(objArray: TObj[], clearAll?: boolean) {
                    var self = this, newItems:TItem[] = [], positions:number[] = [], fetchedItems:TItem[] = [];
                    if (!objArray)
                        objArray = [];
                    this._onFillStart({ isBegin: true, rowCount: objArray.length, time: new Date(), isPageChanged: false });
                    try {
                        if (!!clearAll) this.clear();
                        objArray.forEach(function (obj) {
                            var listItem: ListItemAspect<TItem, TObj> = new ListItemAspect<TItem, TObj>(self, self._itemType, obj);
                            var item = listItem.getItem();
                            listItem._key = self._getNewKey(item);
                            var oldItem = self._itemsByKey[listItem._key];
                            if (!oldItem) {
                                self._items.push(item);
                                self._itemsByKey[listItem._key] = item;
                                newItems.push(item);
                                positions.push(self._items.length - 1);
                                fetchedItems.push(item);
                            }
                            else {
                                fetchedItems.push(oldItem);
                            }
                        });

                        if (newItems.length > 0) {
                            this._onItemsChanged({ change_type: COLL_CHANGE_TYPE.ADDED, items: newItems, pos: positions });
                            this.raisePropertyChanged('count');
                        }
                    }
                    finally {
                        this._onFillEnd({
                            isBegin: false, rowCount: fetchedItems.length, time: new Date(), resetUI: !!clearAll,
                            fetchedItems: fetchedItems, newItems: newItems, isPageChanged: false
                        });
                    }
                    this.moveFirst();
                }
                toArray() {
                    return this.items.map((item, index, arr) => {
                        return <TObj>utils.cloneObj(item._aspect.vals);
                    });
                }
                getNewObjects() {
                    return this._items.filter(function (item) {
                        return item._aspect._isNew;
                    });
                }
                resetNewObjects() {
                    this._items.forEach(function (item) {
                        item._aspect._resetIsNew();
                    });
                }
                toString() {
                    return 'BaseList';
                }
            }

            export class BaseDictionary<TItem extends IListItem, TObj> extends BaseList<TItem, TObj>{
                private _keyName: string;
                constructor(itemType: IListItemConstructor<TItem, TObj>, keyName: string, props: IPropInfo[]) {
                    if (!keyName)
                        throw new Error(baseUtils.format(RIAPP.ERRS.ERR_PARAM_INVALID, 'keyName', keyName));
                    this._keyName = keyName;
                    super(itemType, props);
                    var keyFld = this.getFieldInfo(keyName);
                    if (!keyFld)
                        throw new Error(baseUtils.format(RIAPP.ERRS.ERR_DICTKEY_IS_NOTFOUND, keyName));
                    keyFld.isPrimaryKey = 1;
                }
                protected _getNewKey(item: TItem) {
                    if (!item) {
                        return super._getNewKey(null);
                    }
                    var key = item[this._keyName];
                    if (utils.check.isNt(key))
                        throw new Error(baseUtils.format(RIAPP.ERRS.ERR_DICTKEY_IS_EMPTY, this.keyName));
                    return '' + key;
                }
                protected _onItemAdded(item: TItem) {
                    super._onItemAdded(item);
                    var key = item[this._keyName];
                    this.raisePropertyChanged('[' + key + ']');
                }
                protected _onRemoved(item: TItem, pos: number) {
                    var key = item[this._keyName];
                    super._onRemoved(item, pos);
                    this.raisePropertyChanged('[' + key + ']');
                }
                get keyName() {
                    return this._keyName;
                }
                toString() {
                    return 'BaseDictionary';
                }
            }

            global.onModuleLoaded('collection', collection);
        }
    }
}
